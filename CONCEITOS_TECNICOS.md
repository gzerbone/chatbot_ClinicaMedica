# üìö Conceitos T√©cnicos do Projeto - Chatbot Cl√≠nica M√©dica

Este documento explica todos os conceitos t√©cnicos utilizados no desenvolvimento do chatbot, desde os mais b√°sicos at√© os mais avan√ßados, com exemplos pr√°ticos do nosso projeto.

---

## üåê **CONCEITOS DE REDE E WEB**

### **API (Application Programming Interface)**

**O que √©:**
Uma API √© um conjunto de regras e protocolos que permite que diferentes aplica√ß√µes se comuniquem entre si. √â como um "gar√ßom" que leva pedidos de um cliente (aplica√ß√£o) para a cozinha (servidor) e traz a resposta de volta.

**No nosso projeto:**
```python
# Exemplo: WhatsApp Business API
POST https://graph.facebook.com/v18.0/{phone_number_id}/messages
{
    "messaging_product": "whatsapp",
    "to": "5511999999999",
    "type": "text",
    "text": {"body": "Ol√°! Como posso ajudar?"}
}
```

**Caracter√≠sticas:**
- **Interface padronizada** para comunica√ß√£o
- **Abstra√ß√£o** da complexidade interna
- **Reutiliza√ß√£o** de funcionalidades
- **Interoperabilidade** entre sistemas diferentes

---

### **API REST (REpresentational State Transfer)**

**O que √©:**
REST √© um estilo arquitetural para APIs que usa HTTP de forma padronizada. Segue princ√≠pios espec√≠ficos como stateless (sem estado), uso correto de verbos HTTP, e recursos identificados por URLs.

**Princ√≠pios REST:**
1. **Stateless**: Cada requisi√ß√£o √© independente
2. **Client-Server**: Separa√ß√£o clara de responsabilidades
3. **Cacheable**: Respostas podem ser cacheadas
4. **Uniform Interface**: Interface consistente

**No nosso projeto:**
```python
# rag_agent/views.py - Endpoints REST
GET /rag/especialidades/     # Lista especialidades
GET /rag/medicos/           # Lista m√©dicos  
GET /rag/medicos/1/         # Detalhes do m√©dico ID 1
GET /rag/clinica/           # Informa√ß√µes da cl√≠nica

# Seguindo padr√µes REST:
# GET = Buscar dados
# POST = Criar dados
# PUT = Atualizar dados
# DELETE = Remover dados
```

**Vantagens:**
- **Simplicidade** e facilidade de uso
- **Escalabilidade** atrav√©s do stateless
- **Padroniza√ß√£o** reconhecida mundialmente
- **Cache** nativo do HTTP

---

### **Endpoint**

**O que √©:**
Um endpoint √© um ponto de acesso espec√≠fico de uma API. √â uma URL que aceita requisi√ß√µes e retorna dados ou executa a√ß√µes. Cada endpoint tem uma fun√ß√£o espec√≠fica.

**Estrutura t√≠pica:**
```
[M√âTODO] [BASE_URL]/[RECURSO]/[PAR√ÇMETROS]
GET https://api.clinica.com/medicos/1
```

**No nosso projeto:**
```python
# api_gateway/urls.py
urlpatterns = [
    # Webhook do WhatsApp
    path('webhook/whatsapp/', views.whatsapp_webhook, name='whatsapp_webhook'),
    
    # Endpoints de teste
    path('test/send-message/', views.send_test_message, name='send_test_message'),
    path('test/gemini/', views.test_gemini_connection, name='test_gemini'),
    path('test/intent/', views.test_intent_detection, name='test_intent'),
]

# rag_agent/urls.py  
urlpatterns = [
    path('especialidades/', EspecialidadeListView.as_view(), name='especialidades-list'),
    path('medicos/', MedicoViewSet.as_view({'get': 'list'}), name='medicos-list'),
    path('clinica/', ClinicaInfoView.as_view(), name='clinica-info'),
]
```

**Tipos de endpoints no projeto:**
- **Webhook**: Recebe dados externos (WhatsApp)
- **REST**: Fornece dados estruturados (m√©dicos, especialidades)
- **Teste**: Valida funcionamento do sistema

---

## üö™ **GATEWAY E MIDDLEWARE**

### **API Gateway**

**O que √©:**
Um API Gateway √© um ponto de entrada √∫nico que gerencia, roteia e processa todas as requisi√ß√µes para diferentes servi√ßos de backend. Atua como um "porteiro" inteligente.

**Fun√ß√µes principais:**
- **Roteamento** de requisi√ß√µes
- **Autentica√ß√£o** e autoriza√ß√£o
- **Rate limiting** (controle de frequ√™ncia)
- **Logging** e monitoramento
- **Transforma√ß√£o** de dados

**No nosso projeto:**
```python
# api_gateway/ - Nosso Gateway
‚îú‚îÄ‚îÄ views.py              # Processamento principal
‚îú‚îÄ‚îÄ middleware.py         # Intercepta√ß√£o de requisi√ß√µes  
‚îú‚îÄ‚îÄ services/            # Servi√ßos especializados
‚îÇ   ‚îú‚îÄ‚îÄ whatsapp_service.py    # Comunica√ß√£o WhatsApp
‚îÇ   ‚îú‚îÄ‚îÄ intent_detection_service.py  # An√°lise de inten√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ rag_service.py         # Acesso aos dados
‚îî‚îÄ‚îÄ urls.py              # Roteamento

# Fluxo do Gateway:
WhatsApp ‚Üí API Gateway ‚Üí Flow Agent (Gemini) ‚Üí RAG Agent (Dados) ‚Üí Resposta
```

**Vantagens:**
- **Centraliza√ß√£o** do controle de acesso
- **Abstra√ß√£o** da complexidade interna
- **Monitoramento** centralizado
- **Seguran√ßa** em camadas

---

### **Middleware**

**O que √©:**
Middleware √© um software que fica entre diferentes componentes, interceptando e processando requisi√ß√µes antes que cheguem ao destino final. √â como uma "esteira de produ√ß√£o" onde cada middleware executa uma fun√ß√£o espec√≠fica.

**Como funciona:**
```
Requisi√ß√£o ‚Üí Middleware 1 ‚Üí Middleware 2 ‚Üí Middleware 3 ‚Üí View ‚Üí Resposta
                ‚Üë              ‚Üë              ‚Üë
            CORS         Autentica√ß√£o    Logging
```

**No nosso projeto:**
```python
# core/settings.py
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',                    # 1. CORS
    'django.middleware.security.SecurityMiddleware',           # 2. Seguran√ßa
    'django.contrib.sessions.middleware.SessionMiddleware',    # 3. Sess√µes
    'django.middleware.common.CommonMiddleware',               # 4. Comum
    'api_gateway.middleware.WhatsAppWebhookCSRFExemptMiddleware', # 5. CSRF Custom
    'django.middleware.csrf.CsrfViewMiddleware',              # 6. CSRF
    'django.contrib.auth.middleware.AuthenticationMiddleware', # 7. Autentica√ß√£o
    'django.contrib.messages.middleware.MessageMiddleware',    # 8. Mensagens
    'django.middleware.clickjacking.XFrameOptionsMiddleware',  # 9. Clickjacking
    'api_gateway.middleware.RequestLoggingMiddleware',         # 10. Logging Custom
]

# api_gateway/middleware.py - Nossos middlewares customizados
class WhatsAppWebhookCSRFExemptMiddleware(MiddlewareMixin):
    """Desabilita CSRF apenas para webhook do WhatsApp"""
    
    def process_request(self, request):
        if request.path.startswith('/api/webhook/whatsapp/'):
            setattr(request, '_dont_enforce_csrf_checks', True)
            logger.debug("CSRF check disabled for WhatsApp webhook")

class RequestLoggingMiddleware(MiddlewareMixin):
    """Registra logs de todas as requisi√ß√µes da API"""
    
    def process_request(self, request):
        if request.path.startswith('/api/'):
            logger.info(f"API Request: {request.method} {request.path}")
    
    def process_response(self, request, response):
        if request.path.startswith('/api/'):
            logger.info(f"API Response: {response.status_code}")
        return response
```

**Tipos de middleware:**
- **Seguran√ßa**: CSRF, XSS, autentica√ß√£o
- **Logging**: Registro de atividades
- **CORS**: Controle de acesso cross-origin
- **Custom**: Funcionalidades espec√≠ficas do projeto

---

## üîó **WEBHOOK**

**O que √©:**
Um webhook √© um mecanismo que permite que uma aplica√ß√£o envie dados automaticamente para outra aplica√ß√£o quando um evento espec√≠fico ocorre. √â como uma "campainha" que toca quando algo acontece.

**Diferen√ßa entre API e Webhook:**
```
API (Pull):     Cliente ‚Üí Servidor (Cliente puxa dados)
Webhook (Push): Servidor ‚Üí Cliente (Servidor empurra dados)
```

**No nosso projeto:**
```python
# WhatsApp ‚Üí Nosso Webhook quando paciente envia mensagem
POST /api/webhook/whatsapp/
{
  "entry": [{
    "changes": [{
      "field": "messages",
      "value": {
        "messages": [{
          "id": "wamid.123",
          "from": "5511999999999",
          "text": {"body": "Ol√°, preciso de ajuda"}
        }]
      }
    }]
  }]
}

# api_gateway/views.py
@csrf_exempt  # Webhook n√£o pode ter CSRF
@require_http_methods(["GET", "POST"])
def whatsapp_webhook(request):
    if request.method == 'GET':
        return verify_webhook(request)  # Verifica√ß√£o inicial
    elif request.method == 'POST':
        return handle_webhook(request)  # Processar mensagem
```

**Caracter√≠sticas:**
- **Tempo real**: Dados chegam imediatamente
- **Event-driven**: Baseado em eventos
- **Eficiiente**: N√£o h√° polling desnecess√°rio
- **Ass√≠ncrono**: N√£o bloqueia outras opera√ß√µes

**Configura√ß√£o no Meta (WhatsApp):**
```
Callback URL: https://sua-url.ngrok-free.app/api/webhook/whatsapp/
Verify Token: meu_verify_token_123
Events: messages (quando paciente envia mensagem)
```

---

## üìù **LOGGING**

**O que √©:**
Logging √© o processo de registrar eventos, erros e informa√ß√µes importantes que ocorrem durante a execu√ß√£o de uma aplica√ß√£o. √â como um "di√°rio" detalhado do sistema.

**N√≠veis de Log:**
```
DEBUG    ‚Üí Informa√ß√µes detalhadas para debugging
INFO     ‚Üí Informa√ß√µes gerais sobre o funcionamento
WARNING  ‚Üí Algo inesperado, mas n√£o cr√≠tico
ERROR    ‚Üí Erro que impediu uma opera√ß√£o
CRITICAL ‚Üí Erro grave que pode parar o sistema
```

**No nosso projeto:**
```python
# core/settings.py - Configura√ß√£o do logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'api_gateway': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'flow_agent': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}

# Uso nos arquivos Python
import logging
logger = logging.getLogger(__name__)

# Exemplos de uso:
logger.info(f"Mensagem recebida de {from_number}")
logger.debug(f"Intent detectado: {intent} (confian√ßa: {confidence})")
logger.warning("GEMINI_API_KEY n√£o configurada")
logger.error(f"Erro ao enviar mensagem: {e}")
```

**Sa√≠da dos logs:**
```
INFO api_gateway.views: Mensagem recebida de 5511999999999
DEBUG api_gateway.services.intent_detection: Intent: buscar_medico (0.85)
INFO api_gateway.services.whatsapp: Mensagem enviada com sucesso
```

**Benef√≠cios:**
- **Debugging**: Identificar problemas
- **Monitoramento**: Acompanhar performance
- **Auditoria**: Rastrear atividades
- **Analytics**: Entender padr√µes de uso

---

## üõ†Ô∏è **SERVICES (CAMADA DE SERVI√áOS)**

**O que √©:**
Services s√£o classes que encapsulam l√≥gica de neg√≥cio espec√≠fica, mantendo o c√≥digo organizado e reutiliz√°vel. √â como ter "especialistas" para cada tipo de tarefa.

**Padr√£o Service:**
```
Controller (View) ‚Üí Service ‚Üí Model/External API ‚Üí Response
```

**No nosso projeto:**
```python
# api_gateway/services/ - Nossos servi√ßos

# 1. WhatsApp Service - Comunica√ß√£o com WhatsApp API
class WhatsAppService:
    def send_message(self, to: str, message: str) -> bool:
        """Envia mensagem via WhatsApp Business API"""
        
    def mark_message_as_read(self, message_id: str) -> bool:
        """Marca mensagem como lida"""
        
    def validate_webhook(self, mode: str, token: str, challenge: str) -> str:
        """Valida webhook do WhatsApp"""

# 2. Intent Detection Service - An√°lise de inten√ß√µes
class IntentDetectionService:
    def detect_intent(self, message: str) -> tuple:
        """Detecta inten√ß√£o da mensagem do usu√°rio"""
        
    def extract_entities(self, message: str) -> dict:
        """Extrai entidades (nomes, especialidades, etc.)"""

# 3. RAG Service - Acesso aos dados da cl√≠nica  
class RAGService:
    @staticmethod
    def get_all_clinic_data() -> dict:
        """Obt√©m todos os dados da cl√≠nica"""
        
    @staticmethod
    def get_medicos() -> list:
        """Busca m√©dicos dispon√≠veis"""

# flow_agent/services/
# 4. Gemini Service - Integra√ß√£o com IA
class GeminiService:
    def generate_response(self, user_message, intent, context, clinic_data):
        """Gera resposta usando Gemini AI"""
        
    def test_connection(self) -> bool:
        """Testa conex√£o com Gemini"""
```

**Vantagens dos Services:**
- **Separa√ß√£o de responsabilidades**
- **Reutiliza√ß√£o** de c√≥digo
- **Testabilidade** individual
- **Manutenibilidade** melhorada
- **Abstra√ß√£o** de complexidade

---

## üèóÔ∏è **ARQUITETURA MVC/MVT**

**O que √©:**
MVC (Model-View-Controller) ou MVT (Model-View-Template) no Django √© um padr√£o arquitetural que separa a aplica√ß√£o em tr√™s camadas distintas.

**Django MVT:**
```
Model    ‚Üí Dados e l√≥gica de neg√≥cio (models.py)
View     ‚Üí L√≥gica de apresenta√ß√£o (views.py)  
Template ‚Üí Interface do usu√°rio (templates/)
```

**No nosso projeto:**
```python
# MODEL - rag_agent/models.py
class Medico(models.Model):
    nome = models.CharField(max_length=200)
    crm = models.CharField(max_length=20, unique=True)
    especialidades = models.ManyToManyField(Especialidade)

# VIEW - api_gateway/views.py  
def whatsapp_webhook(request):
    """Processa webhooks do WhatsApp"""
    if request.method == 'POST':
        return handle_webhook(request)

# SERIALIZER (equivalente ao Template para APIs)
class MedicoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Medico
        fields = ['id', 'nome', 'crm', 'especialidades']
```

**Fluxo MVT no projeto:**
```
WhatsApp ‚Üí View (webhook) ‚Üí Service ‚Üí Model ‚Üí Serializer ‚Üí JSON Response
```

---

## üìä **SERIALIZERS (DRF)**

**O que √©:**
Serializers convertem dados complexos (como inst√¢ncias de modelo Django) em tipos nativos Python que podem ser facilmente renderizados em JSON, XML ou outros formatos.

**Fun√ß√µes:**
- **Serializa√ß√£o**: Model ‚Üí JSON
- **Deserializa√ß√£o**: JSON ‚Üí Model
- **Valida√ß√£o**: Dados de entrada
- **Transforma√ß√£o**: Formata√ß√£o de dados

**No nosso projeto:**
```python
# rag_agent/serializers.py
class MedicoResumoSerializer(serializers.ModelSerializer):
    """Serializer resumido para listagem de m√©dicos"""
    especialidades = serializers.StringRelatedField(many=True, read_only=True)
    
    class Meta:
        model = Medico
        fields = ['id', 'nome', 'crm', 'especialidades']

class MedicoSerializer(serializers.ModelSerializer):
    """Serializer completo com todos os detalhes"""
    especialidades = EspecialidadeSerializer(many=True, read_only=True)
    convenios = ConvenioSerializer(many=True, read_only=True)
    horarios_trabalho = HorarioTrabalhoSerializer(many=True, read_only=True)
    
    class Meta:
        model = Medico
        fields = '__all__'

# Uso nos Services:
medicos = Medico.objects.all()
serialized_data = MedicoResumoSerializer(medicos, many=True).data
# Resultado: [{"id": 1, "nome": "Dr. Jo√£o", "crm": "123456", ...}]
```

**Vantagens:**
- **Automa√ß√£o** da convers√£o de dados
- **Valida√ß√£o** integrada
- **Flexibilidade** de campos
- **Consist√™ncia** na API

---

## üîÑ **DJANGO REST FRAMEWORK (DRF)**

**O que √©:**
DRF √© um toolkit poderoso e flex√≠vel para construir APIs REST no Django. Fornece componentes prontos para serializa√ß√£o, autentica√ß√£o, permiss√µes e muito mais.

**Componentes principais:**
```python
# 1. ViewSets - Conjuntos de views relacionadas
class MedicoViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Medico.objects.all()
    serializer_class = MedicoSerializer

# 2. Generic Views - Views pr√©-constru√≠das
class EspecialidadeListView(generics.ListAPIView):
    queryset = Especialidade.objects.filter(ativa=True)
    serializer_class = EspecialidadeSerializer

# 3. Function-based Views com decorators
@api_view(['GET'])
@permission_classes([AllowAny])
def test_gemini_connection(request):
    return Response({'status': 'OK'})

# 4. Routers - Roteamento autom√°tico
router = DefaultRouter()
router.register(r'medicos', MedicoViewSet)
urlpatterns = router.urls
```

**Features utilizadas no projeto:**
- **Serializers**: Convers√£o de dados
- **Generic Views**: Views padronizadas
- **Permissions**: Controle de acesso
- **Response**: Respostas HTTP estruturadas

---

## üóÑÔ∏è **ORM (Object-Relational Mapping)**

**O que √©:**
ORM √© uma t√©cnica que permite manipular banco de dados usando programa√ß√£o orientada a objetos, sem escrever SQL diretamente.

**Django ORM:**
```python
# Sem ORM (SQL puro):
cursor.execute("SELECT * FROM medico WHERE especialidade = 'Cardiologia'")

# Com ORM Django:
medicos = Medico.objects.filter(especialidades__nome='Cardiologia')

# Exemplos do projeto:
# rag_agent/models.py
class Medico(models.Model):
    nome = models.CharField(max_length=200)
    crm = models.CharField(max_length=20, unique=True)
    especialidades = models.ManyToManyField(Especialidade)
    
    def __str__(self):
        return self.nome

# Queries complexas:
medicos_cardiologia = Medico.objects.filter(
    especialidades__nome='Cardiologia',
    especialidades__ativa=True
).prefetch_related('convenios', 'horarios_trabalho')

# Relacionamentos:
medico = Medico.objects.get(id=1)
especialidades = medico.especialidades.all()  # Many-to-Many
horarios = medico.horarios_trabalho.all()     # Foreign Key reversa
```

**Vantagens:**
- **Abstra√ß√£o** do SQL
- **Portabilidade** entre bancos
- **Seguran√ßa** contra SQL injection
- **Produtividade** no desenvolvimento

---

## üîê **CSRF (Cross-Site Request Forgery)**

**O que √©:**
CSRF √© um tipo de ataque onde um site malicioso executa a√ß√µes n√£o autorizadas em nome de um usu√°rio autenticado em outro site.

**Como funciona:**
```
1. Usu√°rio faz login no site A
2. Usu√°rio visita site malicioso B  
3. Site B faz requisi√ß√£o para site A usando credenciais do usu√°rio
4. Site A executa a√ß√£o n√£o autorizada
```

**Prote√ß√£o no Django:**
```python
# Django adiciona token CSRF automaticamente
{% csrf_token %}  # Em templates

# Em views, o middleware verifica o token
'django.middleware.csrf.CsrfViewMiddleware'

# Para APIs externas (webhooks), desabilitamos:
@csrf_exempt
def whatsapp_webhook(request):
    # WhatsApp n√£o pode enviar token CSRF
    pass

# Ou via middleware customizado:
class WhatsAppWebhookCSRFExemptMiddleware:
    def process_request(self, request):
        if request.path.startswith('/api/webhook/whatsapp/'):
            setattr(request, '_dont_enforce_csrf_checks', True)
```

---

## üåç **CORS (Cross-Origin Resource Sharing)**

**O que √©:**
CORS √© um mecanismo que permite que recursos de uma p√°gina web sejam acessados por outro dom√≠nio, protocolo ou porta.

**Problema sem CORS:**
```
Frontend (localhost:3000) ‚Üí API (localhost:8000) = ‚ùå BLOQUEADO
```

**Solu√ß√£o com CORS:**
```python
# core/settings.py
INSTALLED_APPS = [
    'corsheaders',  # Instalar django-cors-headers
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # Primeiro middleware
]

# Configura√ß√£o para desenvolvimento
CORS_ALLOW_ALL_ORIGINS = True

# Configura√ß√£o para produ√ß√£o
CORS_ALLOWED_ORIGINS = [
    "https://meusite.com",
    "https://app.meusite.com",
]
```

---

## üîß **ENVIRONMENT VARIABLES**

**O que √©:**
Vari√°veis de ambiente s√£o valores configur√°veis externamente √† aplica√ß√£o, usadas para armazenar configura√ß√µes sens√≠veis como chaves de API.

**No nosso projeto:**
```python
# .env (n√£o vai para o Git)
DEBUG=True
SECRET_KEY=django-insecure-abc123
GEMINI_API_KEY=AIzaSyC-sua-chave-aqui
WHATSAPP_ACCESS_TOKEN=EAABs...token-longo
WHATSAPP_VERIFY_TOKEN=meu_verify_token_123

# core/settings.py
from decouple import config

DEBUG = config('DEBUG', default=False, cast=bool)
SECRET_KEY = config('SECRET_KEY')
GEMINI_API_KEY = config('GEMINI_API_KEY', default='')

# Uso nos services:
class GeminiService:
    def __init__(self):
        self.api_key = getattr(settings, 'GEMINI_API_KEY', '')
```

**Benef√≠cios:**
- **Seguran√ßa**: Chaves n√£o ficam no c√≥digo
- **Flexibilidade**: Diferentes configs por ambiente
- **Praticidade**: Mudan√ßas sem redeployment

---

## ü§ñ **INTELIG√äNCIA ARTIFICIAL INTEGRADA**

### **LLM (Large Language Model)**

**O que √©:**
LLMs s√£o modelos de IA treinados em grandes volumes de texto para entender e gerar linguagem natural humana.

**Gemini AI no projeto:**
```python
# flow_agent/services/gemini_service.py
import google.generativeai as genai

class GeminiService:
    def __init__(self):
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
    
    def generate_response(self, user_message, intent, context, clinic_data):
        # Construir prompt contextualizado
        prompt = f"""
        Voc√™ √© um assistente virtual de uma cl√≠nica m√©dica.
        
        Dados da cl√≠nica: {clinic_data}
        Inten√ß√£o do usu√°rio: {intent}
        Mensagem: {user_message}
        
        Responda de forma profissional e √∫til.
        """
        
        response = self.model.generate_content(prompt)
        return response.text
```

### **RAG (Retrieval-Augmented Generation)**

**O que √©:**
RAG combina recupera√ß√£o de informa√ß√µes com gera√ß√£o de texto, permitindo que a IA acesse dados espec√≠ficos para dar respostas mais precisas.

**No nosso projeto:**
```python
# 1. RETRIEVAL - Buscar dados relevantes
clinic_data = RAGService.get_all_clinic_data()
medicos_cardiologia = RAGService.get_medicos_por_especialidade('cardiologia')

# 2. AUGMENTATION - Enriquecer prompt com dados
prompt = f"""
Dados da cl√≠nica: {clinic_data}
M√©dicos dispon√≠veis: {medicos_cardiologia}
Pergunta do usu√°rio: {user_message}
"""

# 3. GENERATION - Gerar resposta contextualizada
response = gemini_service.generate_response(prompt)
```

### **NLP (Natural Language Processing)**

**O que √©:**
NLP √© a capacidade de computadores entenderem e processarem linguagem humana.

**No projeto:**
```python
# api_gateway/services/intent_detection_service.py
class IntentDetectionService:
    def __init__(self):
        self.intent_keywords = {
            'buscar_medico': ['m√©dico', 'doutor', 'dr', 'dra'],
            'agendar_consulta': ['agendar', 'marcar', 'consulta'],
            'buscar_especialidade': ['especialidade', 'cardiologista', 'dermatologista'],
        }
    
    def detect_intent(self, message: str):
        message_lower = message.lower()
        
        for intent, keywords in self.intent_keywords.items():
            matches = sum(1 for keyword in keywords if keyword in message_lower)
            if matches > 0:
                confidence = min(matches / len(keywords) * 2, 1.0)
                return intent, confidence
        
        return 'desconhecida', 0.0
```

---

## üìà **MONITORAMENTO E M√âTRICAS**

### **Health Check**

**O que √©:**
Endpoints que verificam se o sistema est√° funcionando corretamente.

```python
# api_gateway/views.py
@api_view(['GET'])
def health_check(request):
    """Verifica sa√∫de do sistema"""
    checks = {
        'database': test_database_connection(),
        'gemini': gemini_service.test_connection(),
        'whatsapp': test_whatsapp_connection(),
    }
    
    all_healthy = all(checks.values())
    status_code = 200 if all_healthy else 503
    
    return Response({
        'status': 'healthy' if all_healthy else 'unhealthy',
        'checks': checks,
        'timestamp': timezone.now()
    }, status=status_code)
```

### **M√©tricas de Performance**

```python
import time
from functools import wraps

def measure_time(func):
    """Decorator para medir tempo de execu√ß√£o"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        logger.info(f"{func.__name__} executado em {end_time - start_time:.2f}s")
        return result
    return wrapper

@measure_time
def generate_response(self, user_message, intent, context, clinic_data):
    # Fun√ß√£o medida automaticamente
    pass
```

---

## üîÑ **PADR√ïES DE DESIGN UTILIZADOS**

### **1. Service Layer Pattern**
```python
# Separa√ß√£o de responsabilidades
View ‚Üí Service ‚Üí Model
```

### **2. Repository Pattern**
```python
# RAGService atua como repository
class RAGService:
    @staticmethod
    def get_medicos():
        return Medico.objects.all()
```

### **3. Factory Pattern**
```python
# GeminiService cria inst√¢ncias configuradas
def create_gemini_service():
    return GeminiService(
        api_key=settings.GEMINI_API_KEY,
        model='gemini-1.5-flash'
    )
```

### **4. Observer Pattern**
```python
# Webhook √© um observer de eventos do WhatsApp
WhatsApp Event ‚Üí Webhook Notification ‚Üí Process Message
```

---

## üöÄ **DEPLOYMENT E INFRAESTRUTURA**

### **Development vs Production**

**Development:**
```python
# Configura√ß√µes de desenvolvimento
DEBUG = True
ALLOWED_HOSTS = ['localhost', '127.0.0.1', '.ngrok-free.app']
DATABASE = SQLite
SERVER = Django Development Server
TUNNEL = ngrok
```

**Production (futuro):**
```python
# Configura√ß√µes de produ√ß√£o  
DEBUG = False
ALLOWED_HOSTS = ['meusite.com']
DATABASE = PostgreSQL
SERVER = Gunicorn + Nginx
HTTPS = SSL Certificate
CACHE = Redis
QUEUE = Celery
MONITORING = Sentry
```

### **Docker (conceito para futuro)**
```dockerfile
# Dockerfile
FROM python:3.10
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["gunicorn", "core.wsgi:application"]
```

---

## üìö **RESUMO DOS CONCEITOS**

| Conceito | O que √© | Onde est√° no projeto |
|----------|---------|---------------------|
| **API** | Interface de comunica√ß√£o | WhatsApp Business API |
| **REST** | Estilo arquitetural para APIs | `rag_agent/views.py` |
| **Endpoint** | Ponto de acesso da API | `/api/webhook/whatsapp/` |
| **Gateway** | Ponto de entrada √∫nico | `api_gateway/` |
| **Middleware** | Interceptador de requisi√ß√µes | `api_gateway/middleware.py` |
| **Webhook** | Notifica√ß√£o autom√°tica | WhatsApp ‚Üí Django |
| **Service** | Camada de l√≥gica de neg√≥cio | `services/` |
| **Logging** | Registro de eventos | `settings.LOGGING` |
| **ORM** | Mapeamento objeto-relacional | Django Models |
| **Serializer** | Convers√£o de dados | DRF Serializers |
| **CSRF** | Prote√ß√£o contra ataques | Django Middleware |
| **CORS** | Controle de acesso cross-origin | `django-cors-headers` |
| **Environment Variables** | Configura√ß√µes externas | `.env` |
| **LLM** | Modelo de linguagem | Gemini AI |
| **RAG** | Gera√ß√£o aumentada por recupera√ß√£o | RAGService + Gemini |
| **NLP** | Processamento de linguagem natural | Intent Detection |

---

**Esta documenta√ß√£o serve como refer√™ncia completa para entender todos os conceitos t√©cnicos utilizados no projeto do chatbot!** üéìüìö
